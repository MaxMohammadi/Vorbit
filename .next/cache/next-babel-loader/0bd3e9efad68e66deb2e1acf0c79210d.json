{"ast":null,"code":"import { getSatellitePositions } from \"./satellites\";\nimport * as h3 from \"h3-js\";\nimport KDBush from \"kdbush\";\nimport * as geokdbush from \"geokdbush\";\nimport { DEFAULT_COVERAGE_RESOLUTION, DEFAULT_COVERAGE_ELEVATION } from \"./constants\";\n\n// coverage radius\n\nexport function getSatelliteCoverageRadius(height = 550,\n// height of satellite\nelevation = DEFAULT_COVERAGE_ELEVATION // elevation from horizon\n) {\n  // http://www.phiphase.com/satellite_coverage.htm\n  const phi = (90 + elevation) * (Math.PI / 180);\n  const radiusEarth = 6372;\n\n  // Math.sin(alpha) / radiusEarth = (Math.sin(phi) / (radiusEarth + height));\n  // Math.sin(alpha) = (Math.sin(phi) / (radiusEarth + height)) * radiusEarth;\n  const alpha = Math.asin(Math.sin(phi) / (radiusEarth + height) * radiusEarth);\n\n  // theta + phi + alpha = Math.PI\n  const theta = Math.PI - phi - alpha;\n\n  // R = theta * radiusEarth\n  return theta * radiusEarth;\n}\n\n// cells and cell indexes\n\nexport function getCellsForResolution(resolution = DEFAULT_COVERAGE_RESOLUTION) {\n  return h3.getRes0Indexes().map(cell => h3.h3ToChildren(cell, resolution)).flat();\n}\nfunction getCellIndexes({\n  cells,\n  resolution = DEFAULT_COVERAGE_RESOLUTION\n}) {\n  if (cells) {\n    return getCellIndexesForCells(cells);\n  } else {\n    return getCellIndexesForResolution(resolution);\n  }\n}\nfunction getCellIndexesForCells(cells) {\n  const points = cells.map(cell => {\n    const [lat, lng] = h3.h3ToGeo(cell);\n    return {\n      cell,\n      lat,\n      lng\n    };\n  });\n  const positionIndex = {};\n  for (const point of points) {\n    positionIndex[point.cell] = point;\n  }\n  const distanceIndex = new KDBush(points, p => p.lng, p => p.lat);\n  return {\n    cells,\n    positionIndex,\n    distanceIndex\n  };\n}\nconst indexesByResolution = {};\nfunction getCellIndexesForResolution(resolution = DEFAULT_COVERAGE_RESOLUTION) {\n  // memoized by resolution\n  if (!indexesByResolution[resolution]) {\n    const cells = getCellsForResolution(resolution);\n    indexesByResolution[resolution] = getCellIndexesForCells(cells);\n  }\n  return indexesByResolution[resolution];\n}\n\n// coverage maps\n\nexport function makeCoverage(cells) {\n  const coverage = {};\n  for (const cell of cells) {\n    coverage[cell] = 0;\n  }\n  return coverage;\n}\nexport function computeCoverage({\n  // \"satellites\" required\n  satellites,\n  // specify periods\n  start = Date.now(),\n  period = 1000 * 60,\n  // 60 seconds\n  periods = 60,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({\n    cells,\n    resolution\n  }),\n  coverage = makeCoverage(indexes.cells)\n}) {\n  // console.time();\n  for (let i = 0; i < periods; i++) {\n    const date = new Date(start + period * i);\n    const {\n      satellitesByCell\n    } = computeCoverageAtMoment({\n      date,\n      satellites,\n      elevation,\n      indexes\n    });\n    for (const cell of Object.keys(satellitesByCell)) {\n      coverage[cell]++;\n    }\n  }\n  for (const cell of Object.keys(coverage)) {\n    coverage[cell] /= periods;\n  }\n  // console.timeEnd();\n  return coverage;\n}\nexport const computeCoverageAtMoment = computeCoverageAtMomentKDBush;\n//   const computeCoverageAtMoment = {\n//   \"#brute\": computeCoverageAtDateBruteForce,\n//   \"#kdbush\": computeCoverageAtMomentKDBush,\n//   \"#h3\": computeCoverageAtDateH3KRing,\n// }[window.location.hash];\n// console.log(computeCoverageAtMoment.name);\n\nfunction computeCoverageAtMomentKDBush({\n  date = new Date(),\n  // \"positions\" or \"satellites\" and \"date\" is required\n  satellites = null,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({\n    cells,\n    resolution\n  }),\n  positions = getSatellitePositions(satellites, date, {\n    elevation\n  })\n}) {\n  const satellitesByCell = {};\n  const cellsBySatellite = positions.map((position, index) => {\n    const matches = geokdbush.around(indexes.distanceIndex, position.lng, position.lat, Infinity, position.coverageRadius);\n    return matches.map(({\n      cell\n    }) => {\n      (satellitesByCell[cell] = satellitesByCell[cell] || []).push(index);\n      return cell;\n    });\n  });\n  return {\n    satellitesByCell,\n    cellsBySatellite\n  };\n}\n\n// function computeCoverageAtDateBruteForce({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = DEFAULT_COVERAGE_ELEVATION,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   for (const [cell, cellPosition] of Object.entries(indexes.positionIndex)) {\n//     for (const position of positions) {\n//       if (arePointsNear(cellPosition, position, position.coverageRadius)) {\n//         coverage[cell]++;\n//         break;\n//       }\n//     }\n//   }\n// }\n\n// function computeCoverageAtDateH3KRing({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = 40,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   const covered = {};\n//   for (const position of positions) {\n//     const checked = {};\n//     const check = (cell, skipDistanceCheck = false) => {\n//       if (checked[cell]) {\n//         return;\n//       }\n//       checked[cell] = true;\n//       if (\n//         skipDistanceCheck ||\n//         arePointsNear(\n//           indexes.positionIndex[cell],\n//           position,\n//           position.coverageRadius\n//         )\n//       ) {\n//         if (!covered[cell]) {\n//           covered[cell] = true;\n//           coverage[cell]++;\n//         }\n//         for (const neighbor of h3.kRing(cell, 1)) {\n//           check(neighbor);\n//         }\n//       }\n//     };\n//     check(h3.geoToH3(position.lat, position.lng, 2), true);\n//   }\n// }","map":null,"metadata":{},"sourceType":"module"}