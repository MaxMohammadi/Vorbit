{"ast":null,"code":"import { getSatellitePositions } from \"./satellites\";\nimport * as h3 from \"h3-js\";\nimport KDBush from \"kdbush\";\nimport * as geokdbush from \"geokdbush\";\nimport { DEFAULT_COVERAGE_RESOLUTION, DEFAULT_COVERAGE_ELEVATION } from \"./constants\";\n\n// coverage radius\n\nexport function getSatelliteCoverageRadius(height = 550,\n// height of satellite\nelevation = DEFAULT_COVERAGE_ELEVATION // elevation from horizon\n) {\n  // http://www.phiphase.com/satellite_coverage.htm\n  const phi = (90 + elevation) * (Math.PI / 180);\n  const radiusEarth = 6372;\n\n  // Math.sin(alpha) / radiusEarth = (Math.sin(phi) / (radiusEarth + height));\n  // Math.sin(alpha) = (Math.sin(phi) / (radiusEarth + height)) * radiusEarth;\n  const alpha = Math.asin(Math.sin(phi) / (radiusEarth + height) * radiusEarth);\n\n  // theta + phi + alpha = Math.PI\n  const theta = Math.PI - phi - alpha;\n\n  // R = theta * radiusEarth\n  return theta * radiusEarth;\n}\n\n// cells and cell indexes\n\nexport function getCellsForResolution(resolution = DEFAULT_COVERAGE_RESOLUTION) {\n  return h3.getRes0Indexes().map(cell => h3.h3ToChildren(cell, resolution)).flat();\n}\nfunction getCellIndexes({\n  cells,\n  resolution = DEFAULT_COVERAGE_RESOLUTION\n}) {\n  if (cells) {\n    return getCellIndexesForCells(cells);\n  } else {\n    return getCellIndexesForResolution(resolution);\n  }\n}\nfunction getCellIndexesForCells(cells) {\n  const points = cells.map(cell => {\n    const [lat, lng] = h3.h3ToGeo(cell);\n    return {\n      cell,\n      lat,\n      lng\n    };\n  });\n  const positionIndex = {};\n  for (const point of points) {\n    positionIndex[point.cell] = point;\n  }\n  const distanceIndex = new KDBush(points, p => p.lng, p => p.lat);\n  return {\n    cells,\n    positionIndex,\n    distanceIndex\n  };\n}\nconst indexesByResolution = {};\nfunction getCellIndexesForResolution(resolution = DEFAULT_COVERAGE_RESOLUTION) {\n  // memoized by resolution\n  if (!indexesByResolution[resolution]) {\n    const cells = getCellsForResolution(resolution);\n    indexesByResolution[resolution] = getCellIndexesForCells(cells);\n  }\n  return indexesByResolution[resolution];\n}\n\n// coverage maps\n\nexport function makeCoverage(cells) {\n  const coverage = {};\n  for (const cell of cells) {\n    coverage[cell] = 0;\n  }\n  return coverage;\n}\nexport function computeCoverage({\n  // \"satellites\" required\n  satellites,\n  // specify periods\n  start = Date.now(),\n  period = 1000 * 60,\n  // 60 seconds\n  periods = 60,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({\n    cells,\n    resolution\n  }),\n  coverage = makeCoverage(indexes.cells)\n}) {\n  // console.time();\n  for (let i = 0; i < periods; i++) {\n    const date = new Date(start + period * i);\n    const {\n      satellitesByCell\n    } = computeCoverageAtMoment({\n      date,\n      satellites,\n      elevation,\n      indexes\n    });\n    for (const cell of Object.keys(satellitesByCell)) {\n      coverage[cell]++;\n    }\n  }\n  for (const cell of Object.keys(coverage)) {\n    coverage[cell] /= periods;\n  }\n  // console.timeEnd();\n  return coverage;\n}\nexport const computeCoverageAtMoment = computeCoverageAtMomentKDBush;\n//   const computeCoverageAtMoment = {\n//   \"#brute\": computeCoverageAtDateBruteForce,\n//   \"#kdbush\": computeCoverageAtMomentKDBush,\n//   \"#h3\": computeCoverageAtDateH3KRing,\n// }[window.location.hash];\n// console.log(computeCoverageAtMoment.name);\n\nfunction computeCoverageAtMomentKDBush({\n  date = new Date(),\n  // \"positions\" or \"satellites\" and \"date\" is required\n  satellites = null,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({\n    cells,\n    resolution\n  }),\n  positions = getSatellitePositions(satellites, date, {\n    elevation\n  })\n}) {\n  const satellitesByCell = {};\n  const cellsBySatellite = positions.map((position, index) => {\n    const matches = geokdbush.around(indexes.distanceIndex, position.lng, position.lat, Infinity, position.coverageRadius);\n    return matches.map(({\n      cell\n    }) => {\n      (satellitesByCell[cell] = satellitesByCell[cell] || []).push(index);\n      return cell;\n    });\n  });\n  return {\n    satellitesByCell,\n    cellsBySatellite\n  };\n}\n\n// function computeCoverageAtDateBruteForce({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = DEFAULT_COVERAGE_ELEVATION,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   for (const [cell, cellPosition] of Object.entries(indexes.positionIndex)) {\n//     for (const position of positions) {\n//       if (arePointsNear(cellPosition, position, position.coverageRadius)) {\n//         coverage[cell]++;\n//         break;\n//       }\n//     }\n//   }\n// }\n\n// function computeCoverageAtDateH3KRing({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = 40,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   const covered = {};\n//   for (const position of positions) {\n//     const checked = {};\n//     const check = (cell, skipDistanceCheck = false) => {\n//       if (checked[cell]) {\n//         return;\n//       }\n//       checked[cell] = true;\n//       if (\n//         skipDistanceCheck ||\n//         arePointsNear(\n//           indexes.positionIndex[cell],\n//           position,\n//           position.coverageRadius\n//         )\n//       ) {\n//         if (!covered[cell]) {\n//           covered[cell] = true;\n//           coverage[cell]++;\n//         }\n//         for (const neighbor of h3.kRing(cell, 1)) {\n//           check(neighbor);\n//         }\n//       }\n//     };\n//     check(h3.geoToH3(position.lat, position.lng, 2), true);\n//   }\n// }","map":{"version":3,"names":["getSatellitePositions","h3","KDBush","geokdbush","DEFAULT_COVERAGE_RESOLUTION","DEFAULT_COVERAGE_ELEVATION","getSatelliteCoverageRadius","height","elevation","phi","Math","PI","radiusEarth","alpha","asin","sin","theta","getCellsForResolution","resolution","getRes0Indexes","map","cell","h3ToChildren","flat","getCellIndexes","cells","getCellIndexesForCells","getCellIndexesForResolution","points","lat","lng","h3ToGeo","positionIndex","point","distanceIndex","p","indexesByResolution","makeCoverage","coverage","computeCoverage","satellites","start","Date","now","period","periods","indexes","i","date","satellitesByCell","computeCoverageAtMoment","Object","keys","computeCoverageAtMomentKDBush","positions","cellsBySatellite","position","index","matches","around","Infinity","coverageRadius","push"],"sources":["/Users/maxmohammadi/Vorbit-Space/src/coverage.ts"],"sourcesContent":["import { getSatellitePositions } from \"./satellites\";\n\nimport * as h3 from \"h3-js\";\nimport KDBush from \"kdbush\";\nimport * as geokdbush from \"geokdbush\";\n\nimport {\n  DEFAULT_COVERAGE_RESOLUTION,\n  DEFAULT_COVERAGE_ELEVATION,\n} from \"./constants\";\n\n// coverage radius\n\nexport function getSatelliteCoverageRadius(\n  height = 550, // height of satellite\n  elevation = DEFAULT_COVERAGE_ELEVATION // elevation from horizon\n) {\n  // http://www.phiphase.com/satellite_coverage.htm\n  const phi = (90 + elevation) * (Math.PI / 180);\n  const radiusEarth = 6372;\n\n  // Math.sin(alpha) / radiusEarth = (Math.sin(phi) / (radiusEarth + height));\n  // Math.sin(alpha) = (Math.sin(phi) / (radiusEarth + height)) * radiusEarth;\n  const alpha = Math.asin(\n    (Math.sin(phi) / (radiusEarth + height)) * radiusEarth\n  );\n\n  // theta + phi + alpha = Math.PI\n  const theta = Math.PI - phi - alpha;\n\n  // R = theta * radiusEarth\n  return theta * radiusEarth;\n}\n\n// cells and cell indexes\n\nexport function getCellsForResolution(\n  resolution = DEFAULT_COVERAGE_RESOLUTION\n) {\n  return h3\n    .getRes0Indexes()\n    .map((cell) => h3.h3ToChildren(cell, resolution))\n    .flat();\n}\n\nfunction getCellIndexes({ cells, resolution = DEFAULT_COVERAGE_RESOLUTION }) {\n  if (cells) {\n    return getCellIndexesForCells(cells);\n  } else {\n    return getCellIndexesForResolution(resolution);\n  }\n}\n\nfunction getCellIndexesForCells(cells) {\n  const points = cells.map((cell) => {\n    const [lat, lng] = h3.h3ToGeo(cell);\n    return { cell, lat, lng };\n  });\n  const positionIndex = {};\n  for (const point of points) {\n    positionIndex[point.cell] = point;\n  }\n  const distanceIndex = new KDBush(\n    points,\n    (p) => p.lng,\n    (p) => p.lat\n  );\n  return { cells, positionIndex, distanceIndex };\n}\n\nconst indexesByResolution = {};\nfunction getCellIndexesForResolution(resolution = DEFAULT_COVERAGE_RESOLUTION) {\n  // memoized by resolution\n  if (!indexesByResolution[resolution]) {\n    const cells = getCellsForResolution(resolution);\n    indexesByResolution[resolution] = getCellIndexesForCells(cells);\n  }\n  return indexesByResolution[resolution];\n}\n\n// coverage maps\n\nexport function makeCoverage(cells) {\n  const coverage = {};\n  for (const cell of cells) {\n    coverage[cell] = 0;\n  }\n  return coverage;\n}\n\nexport function computeCoverage({\n  // \"satellites\" required\n  satellites,\n  // specify periods\n  start = Date.now(),\n  period = 1000 * 60, // 60 seconds\n  periods = 60,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({ cells, resolution }),\n  coverage = makeCoverage(indexes.cells),\n}) {\n  // console.time();\n  for (let i = 0; i < periods; i++) {\n    const date = new Date(start + period * i);\n    const { satellitesByCell } = computeCoverageAtMoment({\n      date,\n      satellites,\n      elevation,\n      indexes,\n    });\n    for (const cell of Object.keys(satellitesByCell)) {\n      coverage[cell]++;\n    }\n  }\n  for (const cell of Object.keys(coverage)) {\n    coverage[cell] /= periods;\n  }\n  // console.timeEnd();\n  return coverage;\n}\n\nexport const computeCoverageAtMoment = computeCoverageAtMomentKDBush;\n//   const computeCoverageAtMoment = {\n//   \"#brute\": computeCoverageAtDateBruteForce,\n//   \"#kdbush\": computeCoverageAtMomentKDBush,\n//   \"#h3\": computeCoverageAtDateH3KRing,\n// }[window.location.hash];\n// console.log(computeCoverageAtMoment.name);\n\nfunction computeCoverageAtMomentKDBush({\n  date = new Date(),\n  // \"positions\" or \"satellites\" and \"date\" is required\n  satellites = null,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({ cells, resolution }),\n  positions = getSatellitePositions(satellites, date, { elevation }),\n}) {\n  const satellitesByCell = {};\n  const cellsBySatellite = positions.map((position, index) => {\n    const matches = geokdbush.around(\n      indexes.distanceIndex,\n      position.lng,\n      position.lat,\n      Infinity,\n      position.coverageRadius\n    );\n    return matches.map(({ cell }) => {\n      (satellitesByCell[cell] = satellitesByCell[cell] || []).push(index);\n      return cell;\n    });\n  });\n  return { satellitesByCell, cellsBySatellite };\n}\n\n// function computeCoverageAtDateBruteForce({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = DEFAULT_COVERAGE_ELEVATION,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   for (const [cell, cellPosition] of Object.entries(indexes.positionIndex)) {\n//     for (const position of positions) {\n//       if (arePointsNear(cellPosition, position, position.coverageRadius)) {\n//         coverage[cell]++;\n//         break;\n//       }\n//     }\n//   }\n// }\n\n// function computeCoverageAtDateH3KRing({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = 40,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   const covered = {};\n//   for (const position of positions) {\n//     const checked = {};\n//     const check = (cell, skipDistanceCheck = false) => {\n//       if (checked[cell]) {\n//         return;\n//       }\n//       checked[cell] = true;\n//       if (\n//         skipDistanceCheck ||\n//         arePointsNear(\n//           indexes.positionIndex[cell],\n//           position,\n//           position.coverageRadius\n//         )\n//       ) {\n//         if (!covered[cell]) {\n//           covered[cell] = true;\n//           coverage[cell]++;\n//         }\n//         for (const neighbor of h3.kRing(cell, 1)) {\n//           check(neighbor);\n//         }\n//       }\n//     };\n//     check(h3.geoToH3(position.lat, position.lng, 2), true);\n//   }\n// }\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}