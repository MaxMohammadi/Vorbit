{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { euclideanDistance } from \"./util\";\nimport { DEFAULT_COVERAGE_RESOLUTION } from \"./constants\";\nimport * as h3 from \"h3-js\";\nimport * as dijkstrajs from \"dijkstrajs\";\nexport function computeShortestPath(pointA, pointB, positions, {\n  links = [],\n  relays = [],\n  satellitesByCell,\n  resolution = DEFAULT_COVERAGE_RESOLUTION\n}) {\n  function satellitesInRange(position) {\n    return satellitesByCell[h3.geoToH3(position.lat, position.lng, resolution)] || [];\n  }\n  positions = Object.create(positions);\n  positions[\"start\"] = _objectSpread(_objectSpread({}, pointA), {}, {\n    height: 0\n  });\n  positions[\"end\"] = _objectSpread(_objectSpread({}, pointB), {}, {\n    height: 0\n  });\n  const graph = {};\n  const addEdge = (a, b, cost = 1) => {\n    graph[a] = graph[a] || {};\n    graph[b] = graph[b] || {};\n    graph[a][b] = cost;\n  };\n\n  // TODO: satellitesByCell only satellites covering the center point of the cell\n  // to be more accurate we should check the actual distance (and expand to surrounding cells)\n  for (const sat of satellitesInRange(positions[\"start\"])) {\n    const distance = euclideanDistance(positions[\"start\"], positions[sat]);\n    addEdge(\"start\", sat, distance);\n  }\n  for (const sat of satellitesInRange(positions[\"end\"])) {\n    const distance = euclideanDistance(positions[\"end\"], positions[sat]);\n    addEdge(sat, \"end\", distance);\n  }\n  for (const [a, b] of links) {\n    const distance = euclideanDistance(positions[a], positions[b]);\n    addEdge(a, b, distance);\n    addEdge(b, a, distance);\n  }\n  for (const [index, relay] of Object.entries(relays)) {\n    positions[`relay-${index}`] = relay;\n    for (const sat of satellitesInRange(relay)) {\n      const distance = euclideanDistance(relay, positions[sat]);\n      addEdge(`relay-${index}`, sat, distance);\n      addEdge(sat, `relay-${index}`, distance);\n    }\n  }\n  const path = dijkstrajs.find_path(graph, \"start\", \"end\");\n  const pathPositions = [];\n  let distance = 0;\n  let prev = null;\n  for (const id of path) {\n    pathPositions.push(positions[id]);\n    const index = pathPositions.length - 1;\n    if (index > 0) {\n      distance += euclideanDistance(pathPositions[index], pathPositions[index - 1]);\n    }\n  }\n  return {\n    path,\n    positions: pathPositions,\n    distance,\n    latency: distance / 300000 * 1000\n  };\n}","map":{"version":3,"names":["euclideanDistance","DEFAULT_COVERAGE_RESOLUTION","h3","dijkstrajs","computeShortestPath","pointA","pointB","positions","links","relays","satellitesByCell","resolution","satellitesInRange","position","geoToH3","lat","lng","Object","create","_objectSpread","height","graph","addEdge","a","b","cost","sat","distance","index","relay","entries","path","find_path","pathPositions","prev","id","push","length","latency"],"sources":["/Users/maxmohammadi/Vorbit-Space/src/routing.ts"],"sourcesContent":["import { euclideanDistance } from \"./util\";\nimport { DEFAULT_COVERAGE_RESOLUTION } from \"./constants\";\n\nimport * as _ from \"lodash\";\nimport * as h3 from \"h3-js\";\n\nimport * as dijkstrajs from \"dijkstrajs\";\n\nexport function computeShortestPath(\n  pointA,\n  pointB,\n  positions,\n  {\n    links = [],\n    relays = [],\n    satellitesByCell,\n    resolution = DEFAULT_COVERAGE_RESOLUTION,\n  }\n) {\n  function satellitesInRange(position) {\n    return (\n      satellitesByCell[h3.geoToH3(position.lat, position.lng, resolution)] || []\n    );\n  }\n\n  positions = Object.create(positions);\n  positions[\"start\"] = { ...pointA, height: 0 };\n  positions[\"end\"] = { ...pointB, height: 0 };\n\n  const graph = {};\n  const addEdge = (a, b, cost = 1) => {\n    graph[a] = graph[a] || {};\n    graph[b] = graph[b] || {};\n    graph[a][b] = cost;\n  };\n\n  // TODO: satellitesByCell only satellites covering the center point of the cell\n  // to be more accurate we should check the actual distance (and expand to surrounding cells)\n  for (const sat of satellitesInRange(positions[\"start\"])) {\n    const distance = euclideanDistance(positions[\"start\"], positions[sat]);\n    addEdge(\"start\", sat, distance);\n  }\n  for (const sat of satellitesInRange(positions[\"end\"])) {\n    const distance = euclideanDistance(positions[\"end\"], positions[sat]);\n    addEdge(sat, \"end\", distance);\n  }\n  for (const [a, b] of links) {\n    const distance = euclideanDistance(positions[a], positions[b]);\n    addEdge(a, b, distance);\n    addEdge(b, a, distance);\n  }\n  for (const [index, relay] of Object.entries(relays)) {\n    positions[`relay-${index}`] = relay;\n    for (const sat of satellitesInRange(relay)) {\n      const distance = euclideanDistance(relay, positions[sat]);\n      addEdge(`relay-${index}`, sat, distance);\n      addEdge(sat, `relay-${index}`, distance);\n    }\n  }\n\n  const path = dijkstrajs.find_path(graph, \"start\", \"end\");\n  const pathPositions = [];\n  let distance = 0;\n  let prev = null;\n  for (const id of path) {\n    pathPositions.push(positions[id]);\n    const index = pathPositions.length - 1;\n    if (index > 0) {\n      distance += euclideanDistance(\n        pathPositions[index],\n        pathPositions[index - 1]\n      );\n    }\n  }\n  return {\n    path,\n    positions: pathPositions,\n    distance,\n    latency: (distance / 300000) * 1000,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}