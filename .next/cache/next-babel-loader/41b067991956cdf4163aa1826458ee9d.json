{"ast":null,"code":"import * as THREE from \"three\";\nimport * as _ from \"lodash\";\nimport { EARTH_RADIUS_KM } from \"../constants\";\nimport { getSatelliteCoverageRadius } from \"../coverage\";\nimport { getGatewaysAround } from \"./gateway\";\nconst objectForSatelliteIndex = _.memoize(index => ({\n  type: \"coverage\",\n  satelliteIndex: index\n}));\nfunction computeRadius(globe, d) {\n  return getSatelliteCoverageRadius(d.position.alt, globe.config.elevation) / EARTH_RADIUS_KM * globe.radius;\n}\nfunction makeCircle(radius, segments = 32) {\n  const vertices = new Float32Array((segments + 1) * 3);\n  const angle = 2 * Math.PI / segments;\n  for (let i = 0; i < segments + 1; i++) {\n    vertices[i * 3] = radius * Math.sin(i * angle);\n    vertices[i * 3 + 1] = radius * Math.cos(i * angle);\n    vertices[i * 3 + 2] = 0;\n  }\n  return vertices;\n}\nfunction makeRing(globe, radius) {\n  // const mesh = new THREE.Mesh(\n  //   new THREE.RingGeometry(radius - globe.radius / 400, radius, 32),\n  //   new THREE.MeshBasicMaterial({\n  //     color: \"rgb(0,100,0)\",\n  //     side: THREE.DoubleSide,\n  //   })\n  // );\n  // mesh._radius = radius;\n  // return mesh;\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\"position\", new THREE.BufferAttribute(makeCircle(radius), 3));\n  const material = new THREE.LineBasicMaterial({\n    color: \"blue\"\n  });\n  const line = new THREE.Line(geometry, material);\n  line._radius = radius;\n  return line;\n}\nexport default {\n  name: \"Coverage (Instantaneous)\",\n  defaultConfig: {},\n  objects({\n    satellites\n  }) {\n    return satellites.map((satellite, index) => objectForSatelliteIndex(index));\n  },\n  create(globe, d) {\n    if (!d.position) {\n      return;\n    }\n    const radius = computeRadius(globe, d);\n    return makeRing(globe, radius);\n  },\n  update(globe, d, obj) {\n    if (!d.position) {\n      return;\n    }\n    const radius = computeRadius(globe, d);\n    if (obj._radius !== radius) {\n      obj.geometry.setAttribute(\"position\", new THREE.BufferAttribute(makeCircle(radius), 3));\n      obj._radius = radius;\n    }\n    Object.assign(obj.position, globe.getCoords(d.position.lat, d.position.lng, 0));\n    const nearGateway = getGatewaysAround(globe.gatewaysIndex, d.position, d.position.coverageRadius).length > 0;\n    obj.material.color.set(nearGateway || !globe.config.layers.gateway.enabled ? \"green\" : \"rgb(100,100,0)\");\n    const globeCenter = globe.scene().localToWorld(new THREE.Vector3(0, 0, 0));\n    obj.lookAt(globeCenter);\n  },\n  renderSettings() {\n    return null;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}