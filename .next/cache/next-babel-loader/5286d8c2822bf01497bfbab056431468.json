{"ast":null,"code":"import * as THREE from \"three\";\nimport * as _ from \"lodash\";\nimport { EARTH_RADIUS_KM } from \"../constants\";\nimport { getSatelliteCoverageRadius } from \"../coverage\";\nimport { getGatewaysAround } from \"./gateway\";\nvar objectForSatelliteIndex = _.memoize(function (index) {\n  return {\n    type: \"coverage\",\n    satelliteIndex: index\n  };\n});\nfunction computeRadius(globe, d) {\n  return getSatelliteCoverageRadius(d.position.alt, globe.config.elevation) / EARTH_RADIUS_KM * globe.radius;\n}\nfunction makeCircle(radius) {\n  var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n  var vertices = new Float32Array((segments + 1) * 3);\n  var angle = 2 * Math.PI / segments;\n  for (var i = 0; i < segments + 1; i++) {\n    vertices[i * 3] = radius * Math.sin(i * angle);\n    vertices[i * 3 + 1] = radius * Math.cos(i * angle);\n    vertices[i * 3 + 2] = 0;\n  }\n  return vertices;\n}\nfunction makeRing(globe, radius) {\n  // const mesh = new THREE.Mesh(\n  //   new THREE.RingGeometry(radius - globe.radius / 400, radius, 32),\n  //   new THREE.MeshBasicMaterial({\n  //     color: \"rgb(0,100,0)\",\n  //     side: THREE.DoubleSide,\n  //   })\n  // );\n  // mesh._radius = radius;\n  // return mesh;\n  var geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\"position\", new THREE.BufferAttribute(makeCircle(radius), 3));\n  var material = new THREE.LineBasicMaterial({\n    color: \"blue\"\n  });\n  var line = new THREE.Line(geometry, material);\n  line._radius = radius;\n  return line;\n}\nexport default {\n  name: \"Coverage (Instantaneous)\",\n  defaultConfig: {},\n  objects: function objects(_ref) {\n    var satellites = _ref.satellites;\n    return satellites.map(function (satellite, index) {\n      return objectForSatelliteIndex(index);\n    });\n  },\n  create: function create(globe, d) {\n    if (!d.position) {\n      return;\n    }\n    var radius = computeRadius(globe, d);\n    return makeRing(globe, radius);\n  },\n  update: function update(globe, d, obj) {\n    if (!d.position) {\n      return;\n    }\n    var radius = computeRadius(globe, d);\n    if (obj._radius !== radius) {\n      obj.geometry.setAttribute(\"position\", new THREE.BufferAttribute(makeCircle(radius), 3));\n      obj._radius = radius;\n    }\n    Object.assign(obj.position, globe.getCoords(d.position.lat, d.position.lng, 0));\n    var nearGateway = getGatewaysAround(globe.gatewaysIndex, d.position, d.position.coverageRadius).length > 0;\n    obj.material.color.set(nearGateway || !globe.config.layers.gateway.enabled ? \"green\" : \"rgb(100,100,0)\");\n    var globeCenter = globe.scene().localToWorld(new THREE.Vector3(0, 0, 0));\n    obj.lookAt(globeCenter);\n  },\n  renderSettings: function renderSettings() {\n    return null;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}