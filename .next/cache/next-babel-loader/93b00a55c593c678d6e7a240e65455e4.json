{"ast":null,"code":"var __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport React from \"react\";\nimport { loadStarlink, generateStarlink } from \"../starlink\";\nimport _ from \"lodash\";\nimport { assocIn, getIn } from \"icepick\";\nimport { startTimer } from \"../timer\";\nimport { getSatellitePositions } from \"../satellites\";\nimport { getCellsForResolution, computeCoverage, computeCoverageAtMoment, makeCoverage } from \"../coverage\";\nimport Globe from \"globe.gl\";\nimport { Setting, SettingNumber, SettingRange, SettingsSection, SettingsLayerSection, SettingsSectionHeader, SettingsButton, SettingsRow, SettingSelect } from \"./settings\";\nimport satelliteLayer from \"../layers/satellite\";\nimport laserLayer, { laserLinksForSatellites } from \"../layers/laser\";\nimport coverageLayer from \"../layers/coverage\";\nimport gatewayLayer, { getGateways, getGatewaysIndex } from \"../layers/gateway\";\nimport routingLayer from \"../layers/routing\";\nimport { computeShortestPath } from \"../routing\";\nconst layers = [satelliteLayer, coverageLayer, gatewayLayer, laserLayer, routingLayer];\nconst GENERATED_PRESETS = [{\n  name: \"Starlink - Original\",\n  value: [{\n    orbitalPlanes: 32,\n    satellitesPerOrbitalPlane: 50,\n    altitude: 1100,\n    inclination: 53\n  }]\n}, {\n  name: \"Starlink - Nov 2018\",\n  value: [{\n    orbitalPlanes: 24,\n    satellitesPerOrbitalPlane: 66,\n    altitude: 550,\n    inclination: 53\n  }]\n}, {\n  name: \"Starlink - Dec 2019\",\n  value: [{\n    orbitalPlanes: 72,\n    satellitesPerOrbitalPlane: 22,\n    altitude: 550,\n    inclination: 53\n  }]\n}];\nconst DEFAULT_CONFIG = {\n  multiplier: 50,\n  elevation: 40,\n  satellitesType: \"starlink\",\n  layers: {},\n  generated: GENERATED_PRESETS[1].value\n};\n\n// settings managed outside of config\nlet multiplier;\nlet elevation;\nconst LAYERS_MAP = {};\nfor (const layer of layers) {\n  LAYERS_MAP[layer.key] = layer;\n  DEFAULT_CONFIG.layers[layer.key] = _objectSpread({}, layer.defaultConfig);\n}\nfunction getConfigFromURL() {\n  try {\n    return JSON.parse(atob(window.location.hash.slice(1)));\n  } catch (e) {\n    return null;\n  }\n}\nfunction setConfigInURL(config) {\n  window.location.hash = \"#\" + btoa(JSON.stringify(config));\n}\nexport default function SatSim() {\n  const ref = React.useRef(null);\n  const [globe, setGlobe] = React.useState(null);\n  const [config, setConfigState] = React.useState(getConfigFromURL() || DEFAULT_CONFIG);\n  const setConfig = (keyPath, value) => {\n    const newConfig = assocIn(config, keyPath, value);\n    setConfigState(newConfig);\n    setConfigInURL(newConfig);\n  };\n  const getConfig = keyPath => getIn(config, keyPath);\n  const inputConfig = keyPath => ({\n    value: getConfig(keyPath),\n    onChange: e => setConfig(keyPath, e.target.value)\n  });\n  const checkboxConfig = keyPath => ({\n    checked: getConfig(keyPath),\n    onChange: e => setConfig(keyPath, e.target.checked)\n  });\n  React.useEffect(() => {\n    const globe = init(ref.current);\n    setGlobe({\n      globe\n    });\n  }, []);\n  const [computedConfig, setComputedConfig] = React.useState(null);\n  React.useEffect(() => {\n    (async () => {\n      let satellites = [];\n      if (config.satellitesType === \"starlink\") {\n        satellites = await loadStarlink();\n      } else if (config.satellitesType === \"generated\") {\n        satellites = generateStarlink(config.generated);\n      }\n      setComputedConfig(_objectSpread(_objectSpread({}, config), {}, {\n        satellites\n      }));\n    })();\n  }, [config]);\n  React.useEffect(() => {\n    if (globe && computedConfig) {\n      globe.globe.config = computedConfig;\n      return update(globe.globe);\n    }\n  }, [globe, computedConfig]);\n\n  // these are stored separately for performance reasons\n  const [multiplier_, setMultiplier] = React.useState(DEFAULT_CONFIG.multiplier);\n  multiplier = multiplier_;\n  const [elevation_, setElevation] = React.useState(DEFAULT_CONFIG.elevation);\n  elevation = elevation_;\n  const setRealTime = () => {\n    setMultiplier(1);\n    globe.date = null;\n    setConfig([\"nonce\"], Date.now());\n  };\n  const [settingsVisible, setSettingsVisible] = React.useState(window.innerWidth > 1000);\n  const settingsProps = {\n    config,\n    inputConfig,\n    checkboxConfig,\n    setConfig,\n    getConfig\n  };\n  return __jsx(\"div\", null, __jsx(\"div\", {\n    className: \"absolute top-0 left-0 bottom-0 right-0 flex flex-col items-center bg-black\",\n    ref: ref\n  }), __jsx(\"div\", {\n    className: \"absolute bottom-0 left-0 text-white p-2\",\n    id: \"time\"\n  }), __jsx(\"div\", {\n    className: \"absolute bottom-0 right-0 text-white p-2\",\n    id: \"fps\"\n  }), __jsx(\"div\", {\n    className: \"absolute bottom-0 right-0 left-0 text-white text-center p-2\",\n    id: \"route\"\n  }), __jsx(\"div\", {\n    className: \"absolute top-0 right-0 text-white\"\n  }, \"SatSim v1.0 \", __jsx(\"a\", {\n    href: \"https://github.com/tlrobinson/satsim\"\n  }, \"(src)\")), settingsVisible ? __jsx(\"div\", {\n    className: \"absolute top-0 left-0 text-white\"\n  }, __jsx(SettingsSectionHeader, null, \"Satellites\", __jsx(\"span\", {\n    className: \"flex-1\"\n  }), __jsx(SettingsButton, {\n    onClick: () => setSettingsVisible(false)\n  }, \"\\xD7\")), __jsx(SettingsSection, null, __jsx(SettingsRow, null, __jsx(SettingSelect, inputConfig([\"satellitesType\"]), __jsx(\"option\", {\n    value: \"starlink\"\n  }, \"Starlink (Live)\"), __jsx(\"option\", {\n    value: \"generated\"\n  }, \"Generated\")), getConfig([\"satellitesType\"]) === \"generated\" && __jsx(SettingSelect, {\n    className: \"ml-2\",\n    value: _.findIndex(GENERATED_PRESETS, ({\n      value\n    }) => _.isEqual(value, config.generated)),\n    onChange: e => setConfig([\"generated\"], GENERATED_PRESETS[e.target.value].value)\n  }, __jsx(\"option\", {\n    disabled: true,\n    value: -1\n  }, \"Select a preset...\"), GENERATED_PRESETS.map(({\n    name\n  }, index) => __jsx(\"option\", {\n    value: index\n  }, name)))), getConfig([\"satellitesType\"]) === \"generated\" && __jsx(\"div\", null, getConfig([\"generated\"]).map((shell, shellIndex, shells) => __jsx(\"div\", {\n    className: \"border-b border-white mt-1 mb-1 pb-1\"\n  }, __jsx(\"div\", {\n    className: \"flex items-center\"\n  }, __jsx(\"strong\", null, \"Orbital Shell \", shellIndex + 1), __jsx(\"span\", null, \" â€“ \", shell.orbitalPlanes * shell.satellitesPerOrbitalPlane, \" \", \"satellites\"), __jsx(\"span\", {\n    className: \"flex-1\"\n  }), shells.length > 1 && __jsx(SettingsButton, {\n    onClick: () => setConfig([\"generated\"], [...shells.slice(0, shellIndex), ...shells.slice(shellIndex + 1)])\n  }, \"\\xD7\"), shellIndex === shells.length - 1 && __jsx(SettingsButton, {\n    onClick: () => setConfig([\"generated\"], [...shells, shell])\n  }, \"+\")), __jsx(Setting, {\n    title: \"Orbital Planes\"\n  }, __jsx(SettingNumber, _extends({\n    min: 1,\n    max: 100\n  }, inputConfig([\"generated\", shellIndex, \"orbitalPlanes\"])))), __jsx(Setting, {\n    title: \"Satellites per Plane\"\n  }, __jsx(SettingNumber, _extends({\n    min: 1,\n    max: 100\n  }, inputConfig([\"generated\", shellIndex, \"satellitesPerOrbitalPlane\"])))), __jsx(Setting, {\n    title: \"Inclination\"\n  }, __jsx(SettingNumber, _extends({\n    min: 0,\n    max: 360\n  }, inputConfig([\"generated\", shellIndex, \"inclination\"])))), __jsx(Setting, {\n    title: \"Altitude\"\n  }, __jsx(SettingNumber, _extends({\n    min: 1,\n    max: 1000\n  }, inputConfig([\"generated\", shellIndex, \"altitude\"]))))))), __jsx(Setting, {\n    title: \"Min Elevation\"\n  }, __jsx(SettingRange, {\n    min: 0,\n    max: 90,\n    value: elevation,\n    onChange: e => setElevation(e.target.value)\n  }), __jsx(\"span\", {\n    className: \"ml-1\"\n  }, elevation, \"\\xB0\"))), __jsx(SettingsSectionHeader, null, \"Time\"), __jsx(SettingsSection, null, __jsx(SettingsRow, null, __jsx(SettingRange, {\n    min: -400,\n    max: 400,\n    value: multiplier,\n    onChange: e => setMultiplier(e.target.value)\n  }), __jsx(\"span\", {\n    className: \"ml-1\"\n  }, multiplier, \"\\xD7\"), __jsx(\"span\", {\n    className: \"flex-1\"\n  }), __jsx(SettingsButton, {\n    onClick: setRealTime\n  }, \"Real-time\"))), __jsx(SettingsSectionHeader, null, \"Layers\"), layers.filter(layer => typeof layer.canEnable !== \"function\" || layer.canEnable(config)).map(layer => __jsx(SettingsLayerSection, {\n    layer: layer,\n    config: config,\n    setConfig: setConfig\n  }, typeof layer.renderSettings === \"function\" && layer.renderSettings(settingsProps)))) : __jsx(\"div\", {\n    className: \"absolute top-0 left-0 text-white\"\n  }, __jsx(SettingsSectionHeader, null, __jsx(SettingsButton, {\n    onClick: () => setSettingsVisible(true)\n  }, \"Settings\"))));\n}\nfunction init(element) {\n  const globe = Globe();\n  globe(element).globeImageUrl(\"//unpkg.com/three-globe/example/img/earth-dark.jpg\")\n  // .bumpImageUrl(\"//unpkg.com/three-globe/example/img/earth-topology.png\")\n  // .backgroundImageUrl(\"//unpkg.com/three-globe/example/img/night-sky.png\")\n  .pointOfView({\n    lat: 38,\n    lng: -100,\n    altitude: 1.5\n  }, 1000).customThreeObject((d, globeRadius) => {\n    globe.radius = globeRadius;\n    if (LAYERS_MAP[d.type]) {\n      return LAYERS_MAP[d.type].create(globe, d, globeRadius);\n    } else {\n      console.warn(\"Unknown type\", d.type);\n    }\n  }).customThreeObjectUpdate((obj, d, globeRadius) => {\n    globe.radius = globeRadius;\n    if (LAYERS_MAP[d.type]) {\n      return LAYERS_MAP[d.type].update(globe, d, obj, globeRadius);\n    }\n  });\n  return globe;\n}\nfunction update(globe) {\n  const {\n    config\n  } = globe;\n  const {\n    satellites\n  } = config;\n  globe.satellites = satellites;\n  const resolution = config.layers.coverage.resolution;\n  const coverageAverageEnabled = config.layers.coverage.enabled && config.layers.coverage.type === \"average\";\n  const routingEnabled = config.layers.routing.enabled;\n  const routingLasersEnabled = config.layers.routing.use_laser_links;\n  const laserEnabled = config.layers.laser.enabled;\n  let coverageTotal;\n  if (coverageAverageEnabled) {\n    globe.cells = getCellsForResolution(resolution);\n    globe.coverage = computeCoverage({\n      resolution,\n      satellites\n    });\n    coverageTotal = makeCoverage(globe.cells);\n  }\n  globe.laserLinks = [];\n  if (laserEnabled || routingEnabled && routingLasersEnabled) {\n    globe.laserLinks = laserLinksForSatellites(satellites, config.layers.laser);\n  }\n  globe.gateways = getGateways(config.layers.gateway);\n  globe.gatewaysIndex = getGatewaysIndex(globe.gateways);\n  const enabledLayers = layers.filter(layer => config.layers[layer.key].enabled);\n  const customLayerData = enabledLayers.flatMap(layer => layer.objects(globe));\n  globe.customLayerData(customLayerData);\n  let ticks = 0;\n  let last;\n  let avgFps;\n  let SMOOTHING = 0.95;\n  function update(date) {\n    ticks++;\n    globe.config.elevation = elevation;\n    const positions = getSatellitePositions(satellites, date, {\n      elevation: globe.config.elevation\n    });\n    globe.positions = positions;\n    globe.date = date;\n    let satellitesByCell, cellsBySatellite;\n    if (coverageAverageEnabled || routingEnabled) {\n      ({\n        satellitesByCell,\n        cellsBySatellite\n      } = computeCoverageAtMoment({\n        elevation: globe.config.elevation,\n        resolution,\n        positions\n      }));\n    }\n    globe.coverage = {};\n    if (coverageAverageEnabled) {\n      for (const cell of Object.keys(coverageTotal)) {\n        coverageTotal[cell] += satellitesByCell[cell] ? 1 : 0;\n        globe.coverage[cell] = coverageTotal[cell] / ticks;\n      }\n    }\n    globe.route = null;\n    document.getElementById(\"route\").textContent = \"\";\n    if (routingEnabled) {\n      const {\n        pointA,\n        pointB,\n        use_laser_links,\n        use_gateways\n      } = globe.config.layers.routing;\n      let links = [];\n      if (use_laser_links) {\n        links.push(...globe.laserLinks);\n      }\n      let relays = [];\n      if (use_gateways) {\n        relays.push(...globe.gateways.map(g => g.position));\n      }\n      try {\n        globe.route = computeShortestPath(pointA, pointB, positions, {\n          links,\n          relays,\n          satellitesByCell,\n          resolution\n        });\n        document.getElementById(\"route\").textContent = `Route distance: ${Math.round(globe.route.distance)} km. Route latency: ~${Math.round(globe.route.latency)} ms`;\n      } catch (e) {\n        document.getElementById(\"route\").textContent = \"Route: none\";\n      }\n    }\n    for (const data of customLayerData) {\n      if (data.satelliteIndex != null) {\n        data.position = positions[data.satelliteIndex];\n      }\n      if (data.satelliteIndexes) {\n        data.positions = data.satelliteIndexes.map(index => positions[index]);\n      }\n    }\n    globe.customLayerData(customLayerData);\n    const now = Date.now();\n    if (last != null) {\n      const fps = 1 / ((now - last) / 1000);\n      avgFps = (avgFps || fps) * SMOOTHING + fps * (1.0 - SMOOTHING);\n      document.getElementById(\"fps\").textContent = avgFps.toFixed(0) + \" FPS\";\n    }\n    last = now;\n    document.getElementById(\"time\").textContent = String(date).replace(/ \\(.*/, \"\");\n  }\n  return startTimer(update, {\n    // start: globe.date ? globe.date.getTime() : Date.now(),\n    multiplier: () => multiplier,\n    interval: 20\n  });\n}","map":null,"metadata":{},"sourceType":"module"}