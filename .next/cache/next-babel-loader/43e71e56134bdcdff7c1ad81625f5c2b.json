{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport * as THREE from \"three\";\nimport chroma from \"chroma-js\";\nimport * as h3 from \"h3-js\";\nimport * as _ from \"lodash\";\nimport { Setting, SettingNumber } from \"../components/settings\";\nconst getCoverageObject = _.memoize(cell => ({\n  type: \"coverage\",\n  cell: cell\n}));\nexport default {\n  name: \"Coverage (Average)\",\n  defaultConfig: {\n    enabled: false,\n    resolution: 2\n  },\n  objects({\n    cells\n  }) {\n    return cells.map(cell => getCoverageObject(cell));\n  },\n  create(globe, d, globeRadius) {\n    const color = cellColor(globe, d.cell);\n    const center = cellCenter(globe, d.cell);\n    const corners = cellCorners(globe, d.cell);\n    if (false) {\n      const geometry = new THREE.BufferGeometry().setFromPoints(corners);\n      const material = new THREE.LineBasicMaterial({\n        color\n      });\n      return new THREE.Line(geometry, material);\n    } else {\n      const geometry = new THREE.Geometry();\n      geometry.vertices.push(center, ...corners);\n      for (let i = 0; i < corners.length - 1; i++) {\n        geometry.faces.push(new THREE.Face3(0, i + 1, i + 2));\n      }\n      geometry.computeFaceNormals();\n      const material = new THREE.MeshBasicMaterial({\n        color: color,\n        opacity: 0.25,\n        transparent: true\n      });\n      return new THREE.Mesh(geometry, material);\n\n      // const geometry = new THREE.Geometry();\n      // addCoverageFace(geometry, globe, d.cell);\n      // geometry.computeFaceNormals();\n      // const material = new THREE.MeshPhongMaterial({\n      //   opacity: 0.25,\n      //   transparent: true,\n      //   vertexColors: true,\n      // });\n      // return new THREE.Mesh(geometry, material);\n    }\n  },\n\n  update(globe, d, obj) {\n    obj.material.color.set(cellColor(globe, d.cell));\n    // obj.material.color.set(Math.random() < 0.5 ? \"red\" : \"green\");\n  },\n\n  renderSettings({\n    inputConfig\n  }) {\n    return __jsx(Setting, {\n      title: \"Resolution\"\n    }, __jsx(SettingNumber, _extends({\n      min: 1,\n      max: 3\n    }, inputConfig([\"layers\", \"coverage\", \"resolution\"]))));\n  }\n};\nconst colorScale = chroma.scale(\"RdYlBu\").domain([0, 1]);\nfunction positionToVector3(globe, [lng, lat], altitude = 0.01) {\n  const {\n    x,\n    y,\n    z\n  } = globe.getCoords(lat, lng, altitude);\n  return new THREE.Vector3(x, y, z);\n}\nfunction cellCorners(globe, cell) {\n  return h3.h3ToGeoBoundary(cell, true).map(bound => positionToVector3(globe, bound));\n}\nfunction cellCenter(globe, cell) {\n  const centerCoords = globe.getCoords(...h3.h3ToGeo(cell), 0.01);\n  return new THREE.Vector3(centerCoords.x, centerCoords.y, centerCoords.z);\n}\nfunction cellColor(globe, cell) {\n  return new THREE.Color(colorScale(globe.coverage[cell]).hex());\n}\nfunction createCoverageMesh(globe, cells) {\n  const geometry = new THREE.Geometry();\n  for (const cell of cells) {\n    addCoverageFace(geometry, globe, cell);\n  }\n  geometry.computeFaceNormals();\n  const material = new THREE.MeshPhongMaterial({\n    opacity: 0.25,\n    transparent: true,\n    vertexColors: true\n  });\n  return new THREE.Mesh(geometry, material);\n}\nfunction addCoverageFace(geometry, globe, cell) {\n  const color = cellColor(globe, cell);\n  const center = cellCenter(globe, cell);\n  const corners = cellCorners(globe, cell);\n  const vertexOffset = geometry.vertices.length;\n  geometry.vertices.push(center, ...corners);\n  for (let i = 0; i < corners.length - 1; i++) {\n    geometry.faces.push(new THREE.Face3(vertexOffset, vertexOffset + i + 1, vertexOffset + i + 2, null, color));\n  }\n}","map":null,"metadata":{},"sourceType":"module"}