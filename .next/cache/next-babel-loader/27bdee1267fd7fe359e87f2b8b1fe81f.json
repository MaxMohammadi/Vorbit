{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { getSatellitePositions } from \"./satellites\";\nimport * as h3 from \"h3-js\";\nimport KDBush from \"kdbush\";\nimport * as geokdbush from \"geokdbush\";\nimport { DEFAULT_COVERAGE_RESOLUTION, DEFAULT_COVERAGE_ELEVATION } from \"./constants\";\n\n// coverage radius\n\nexport function getSatelliteCoverageRadius() {\n  var height = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 550;\n  var elevation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_COVERAGE_ELEVATION;\n  // http://www.phiphase.com/satellite_coverage.htm\n  var phi = (90 + elevation) * (Math.PI / 180);\n  var radiusEarth = 6372;\n\n  // Math.sin(alpha) / radiusEarth = (Math.sin(phi) / (radiusEarth + height));\n  // Math.sin(alpha) = (Math.sin(phi) / (radiusEarth + height)) * radiusEarth;\n  var alpha = Math.asin(Math.sin(phi) / (radiusEarth + height) * radiusEarth);\n\n  // theta + phi + alpha = Math.PI\n  var theta = Math.PI - phi - alpha;\n\n  // R = theta * radiusEarth\n  return theta * radiusEarth;\n}\n\n// cells and cell indexes\n\nexport function getCellsForResolution() {\n  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_COVERAGE_RESOLUTION;\n  return h3.getRes0Indexes().map(function (cell) {\n    return h3.h3ToChildren(cell, resolution);\n  }).flat();\n}\nfunction getCellIndexes(_ref) {\n  var cells = _ref.cells,\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? DEFAULT_COVERAGE_RESOLUTION : _ref$resolution;\n  if (cells) {\n    return getCellIndexesForCells(cells);\n  } else {\n    return getCellIndexesForResolution(resolution);\n  }\n}\nfunction getCellIndexesForCells(cells) {\n  var points = cells.map(function (cell) {\n    var _h3$h3ToGeo = h3.h3ToGeo(cell),\n      _h3$h3ToGeo2 = _slicedToArray(_h3$h3ToGeo, 2),\n      lat = _h3$h3ToGeo2[0],\n      lng = _h3$h3ToGeo2[1];\n    return {\n      cell: cell,\n      lat: lat,\n      lng: lng\n    };\n  });\n  var positionIndex = {};\n  var _iterator = _createForOfIteratorHelper(points),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var point = _step.value;\n      positionIndex[point.cell] = point;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var distanceIndex = new KDBush(points, function (p) {\n    return p.lng;\n  }, function (p) {\n    return p.lat;\n  });\n  return {\n    cells: cells,\n    positionIndex: positionIndex,\n    distanceIndex: distanceIndex\n  };\n}\nvar indexesByResolution = {};\nfunction getCellIndexesForResolution() {\n  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_COVERAGE_RESOLUTION;\n  // memoized by resolution\n  if (!indexesByResolution[resolution]) {\n    var cells = getCellsForResolution(resolution);\n    indexesByResolution[resolution] = getCellIndexesForCells(cells);\n  }\n  return indexesByResolution[resolution];\n}\n\n// coverage maps\n\nexport function makeCoverage(cells) {\n  var coverage = {};\n  var _iterator2 = _createForOfIteratorHelper(cells),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var cell = _step2.value;\n      coverage[cell] = 0;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return coverage;\n}\nexport function computeCoverage(_ref2) {\n  var satellites = _ref2.satellites,\n    _ref2$start = _ref2.start,\n    start = _ref2$start === void 0 ? Date.now() : _ref2$start,\n    _ref2$period = _ref2.period,\n    period = _ref2$period === void 0 ? 1000 * 60 : _ref2$period,\n    _ref2$periods = _ref2.periods,\n    periods = _ref2$periods === void 0 ? 60 : _ref2$periods,\n    _ref2$elevation = _ref2.elevation,\n    elevation = _ref2$elevation === void 0 ? DEFAULT_COVERAGE_ELEVATION : _ref2$elevation,\n    _ref2$resolution = _ref2.resolution,\n    resolution = _ref2$resolution === void 0 ? DEFAULT_COVERAGE_RESOLUTION : _ref2$resolution,\n    _ref2$cells = _ref2.cells,\n    cells = _ref2$cells === void 0 ? null : _ref2$cells,\n    _ref2$indexes = _ref2.indexes,\n    indexes = _ref2$indexes === void 0 ? getCellIndexes({\n      cells: cells,\n      resolution: resolution\n    }) : _ref2$indexes,\n    _ref2$coverage = _ref2.coverage,\n    coverage = _ref2$coverage === void 0 ? makeCoverage(indexes.cells) : _ref2$coverage;\n  // console.time();\n  for (var i = 0; i < periods; i++) {\n    var date = new Date(start + period * i);\n    var _computeCoverageAtMom = computeCoverageAtMoment({\n        date: date,\n        satellites: satellites,\n        elevation: elevation,\n        indexes: indexes\n      }),\n      satellitesByCell = _computeCoverageAtMom.satellitesByCell;\n    for (var _i = 0, _Object$keys = Object.keys(satellitesByCell); _i < _Object$keys.length; _i++) {\n      var cell = _Object$keys[_i];\n      coverage[cell]++;\n    }\n  }\n  for (var _i2 = 0, _Object$keys2 = Object.keys(coverage); _i2 < _Object$keys2.length; _i2++) {\n    var _cell = _Object$keys2[_i2];\n    coverage[_cell] /= periods;\n  }\n  // console.timeEnd();\n  return coverage;\n}\nexport var computeCoverageAtMoment = computeCoverageAtMomentKDBush;\n//   const computeCoverageAtMoment = {\n//   \"#brute\": computeCoverageAtDateBruteForce,\n//   \"#kdbush\": computeCoverageAtMomentKDBush,\n//   \"#h3\": computeCoverageAtDateH3KRing,\n// }[window.location.hash];\n// console.log(computeCoverageAtMoment.name);\n\nfunction computeCoverageAtMomentKDBush(_ref3) {\n  var _ref3$date = _ref3.date,\n    date = _ref3$date === void 0 ? new Date() : _ref3$date,\n    _ref3$satellites = _ref3.satellites,\n    satellites = _ref3$satellites === void 0 ? null : _ref3$satellites,\n    _ref3$elevation = _ref3.elevation,\n    elevation = _ref3$elevation === void 0 ? DEFAULT_COVERAGE_ELEVATION : _ref3$elevation,\n    _ref3$resolution = _ref3.resolution,\n    resolution = _ref3$resolution === void 0 ? DEFAULT_COVERAGE_RESOLUTION : _ref3$resolution,\n    _ref3$cells = _ref3.cells,\n    cells = _ref3$cells === void 0 ? null : _ref3$cells,\n    _ref3$indexes = _ref3.indexes,\n    indexes = _ref3$indexes === void 0 ? getCellIndexes({\n      cells: cells,\n      resolution: resolution\n    }) : _ref3$indexes,\n    _ref3$positions = _ref3.positions,\n    positions = _ref3$positions === void 0 ? getSatellitePositions(satellites, date, {\n      elevation: elevation\n    }) : _ref3$positions;\n  var satellitesByCell = {};\n  var cellsBySatellite = positions.map(function (position, index) {\n    var matches = geokdbush.around(indexes.distanceIndex, position.lng, position.lat, Infinity, position.coverageRadius);\n    return matches.map(function (_ref4) {\n      var cell = _ref4.cell;\n      (satellitesByCell[cell] = satellitesByCell[cell] || []).push(index);\n      return cell;\n    });\n  });\n  return {\n    satellitesByCell: satellitesByCell,\n    cellsBySatellite: cellsBySatellite\n  };\n}\n\n// function computeCoverageAtDateBruteForce({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = DEFAULT_COVERAGE_ELEVATION,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   for (const [cell, cellPosition] of Object.entries(indexes.positionIndex)) {\n//     for (const position of positions) {\n//       if (arePointsNear(cellPosition, position, position.coverageRadius)) {\n//         coverage[cell]++;\n//         break;\n//       }\n//     }\n//   }\n// }\n\n// function computeCoverageAtDateH3KRing({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = 40,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   const covered = {};\n//   for (const position of positions) {\n//     const checked = {};\n//     const check = (cell, skipDistanceCheck = false) => {\n//       if (checked[cell]) {\n//         return;\n//       }\n//       checked[cell] = true;\n//       if (\n//         skipDistanceCheck ||\n//         arePointsNear(\n//           indexes.positionIndex[cell],\n//           position,\n//           position.coverageRadius\n//         )\n//       ) {\n//         if (!covered[cell]) {\n//           covered[cell] = true;\n//           coverage[cell]++;\n//         }\n//         for (const neighbor of h3.kRing(cell, 1)) {\n//           check(neighbor);\n//         }\n//       }\n//     };\n//     check(h3.geoToH3(position.lat, position.lng, 2), true);\n//   }\n// }","map":{"version":3,"names":["getSatellitePositions","h3","KDBush","geokdbush","DEFAULT_COVERAGE_RESOLUTION","DEFAULT_COVERAGE_ELEVATION","getSatelliteCoverageRadius","height","arguments","length","undefined","elevation","phi","Math","PI","radiusEarth","alpha","asin","sin","theta","getCellsForResolution","resolution","getRes0Indexes","map","cell","h3ToChildren","flat","getCellIndexes","_ref","cells","_ref$resolution","getCellIndexesForCells","getCellIndexesForResolution","points","_h3$h3ToGeo","h3ToGeo","_h3$h3ToGeo2","_slicedToArray","lat","lng","positionIndex","_iterator","_createForOfIteratorHelper","_step","s","n","done","point","value","err","e","f","distanceIndex","p","indexesByResolution","makeCoverage","coverage","_iterator2","_step2","computeCoverage","_ref2","satellites","_ref2$start","start","Date","now","_ref2$period","period","_ref2$periods","periods","_ref2$elevation","_ref2$resolution","_ref2$cells","_ref2$indexes","indexes","_ref2$coverage","i","date","_computeCoverageAtMom","computeCoverageAtMoment","satellitesByCell","_i","_Object$keys","Object","keys","_i2","_Object$keys2","computeCoverageAtMomentKDBush","_ref3","_ref3$date","_ref3$satellites","_ref3$elevation","_ref3$resolution","_ref3$cells","_ref3$indexes","_ref3$positions","positions","cellsBySatellite","position","index","matches","around","Infinity","coverageRadius","_ref4","push"],"sources":["/Users/maxmohammadi/Vorbit-Space/src/coverage.ts"],"sourcesContent":["import { getSatellitePositions } from \"./satellites\";\n\nimport * as h3 from \"h3-js\";\nimport KDBush from \"kdbush\";\nimport * as geokdbush from \"geokdbush\";\n\nimport {\n  DEFAULT_COVERAGE_RESOLUTION,\n  DEFAULT_COVERAGE_ELEVATION,\n} from \"./constants\";\n\n// coverage radius\n\nexport function getSatelliteCoverageRadius(\n  height = 550, // height of satellite\n  elevation = DEFAULT_COVERAGE_ELEVATION // elevation from horizon\n) {\n  // http://www.phiphase.com/satellite_coverage.htm\n  const phi = (90 + elevation) * (Math.PI / 180);\n  const radiusEarth = 6372;\n\n  // Math.sin(alpha) / radiusEarth = (Math.sin(phi) / (radiusEarth + height));\n  // Math.sin(alpha) = (Math.sin(phi) / (radiusEarth + height)) * radiusEarth;\n  const alpha = Math.asin(\n    (Math.sin(phi) / (radiusEarth + height)) * radiusEarth\n  );\n\n  // theta + phi + alpha = Math.PI\n  const theta = Math.PI - phi - alpha;\n\n  // R = theta * radiusEarth\n  return theta * radiusEarth;\n}\n\n// cells and cell indexes\n\nexport function getCellsForResolution(\n  resolution = DEFAULT_COVERAGE_RESOLUTION\n) {\n  return h3\n    .getRes0Indexes()\n    .map((cell) => h3.h3ToChildren(cell, resolution))\n    .flat();\n}\n\nfunction getCellIndexes({ cells, resolution = DEFAULT_COVERAGE_RESOLUTION }) {\n  if (cells) {\n    return getCellIndexesForCells(cells);\n  } else {\n    return getCellIndexesForResolution(resolution);\n  }\n}\n\nfunction getCellIndexesForCells(cells) {\n  const points = cells.map((cell) => {\n    const [lat, lng] = h3.h3ToGeo(cell);\n    return { cell, lat, lng };\n  });\n  const positionIndex = {};\n  for (const point of points) {\n    positionIndex[point.cell] = point;\n  }\n  const distanceIndex = new KDBush(\n    points,\n    (p) => p.lng,\n    (p) => p.lat\n  );\n  return { cells, positionIndex, distanceIndex };\n}\n\nconst indexesByResolution = {};\nfunction getCellIndexesForResolution(resolution = DEFAULT_COVERAGE_RESOLUTION) {\n  // memoized by resolution\n  if (!indexesByResolution[resolution]) {\n    const cells = getCellsForResolution(resolution);\n    indexesByResolution[resolution] = getCellIndexesForCells(cells);\n  }\n  return indexesByResolution[resolution];\n}\n\n// coverage maps\n\nexport function makeCoverage(cells) {\n  const coverage = {};\n  for (const cell of cells) {\n    coverage[cell] = 0;\n  }\n  return coverage;\n}\n\nexport function computeCoverage({\n  // \"satellites\" required\n  satellites,\n  // specify periods\n  start = Date.now(),\n  period = 1000 * 60, // 60 seconds\n  periods = 60,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({ cells, resolution }),\n  coverage = makeCoverage(indexes.cells),\n}) {\n  // console.time();\n  for (let i = 0; i < periods; i++) {\n    const date = new Date(start + period * i);\n    const { satellitesByCell } = computeCoverageAtMoment({\n      date,\n      satellites,\n      elevation,\n      indexes,\n    });\n    for (const cell of Object.keys(satellitesByCell)) {\n      coverage[cell]++;\n    }\n  }\n  for (const cell of Object.keys(coverage)) {\n    coverage[cell] /= periods;\n  }\n  // console.timeEnd();\n  return coverage;\n}\n\nexport const computeCoverageAtMoment = computeCoverageAtMomentKDBush;\n//   const computeCoverageAtMoment = {\n//   \"#brute\": computeCoverageAtDateBruteForce,\n//   \"#kdbush\": computeCoverageAtMomentKDBush,\n//   \"#h3\": computeCoverageAtDateH3KRing,\n// }[window.location.hash];\n// console.log(computeCoverageAtMoment.name);\n\nfunction computeCoverageAtMomentKDBush({\n  date = new Date(),\n  // \"positions\" or \"satellites\" and \"date\" is required\n  satellites = null,\n  // misc\n  elevation = DEFAULT_COVERAGE_ELEVATION,\n  // either \"resolution\" or \"cells\" is required\n  resolution = DEFAULT_COVERAGE_RESOLUTION,\n  cells = null,\n  // optimizations\n  indexes = getCellIndexes({ cells, resolution }),\n  positions = getSatellitePositions(satellites, date, { elevation }),\n}) {\n  const satellitesByCell = {};\n  const cellsBySatellite = positions.map((position, index) => {\n    const matches = geokdbush.around(\n      indexes.distanceIndex,\n      position.lng,\n      position.lat,\n      Infinity,\n      position.coverageRadius\n    );\n    return matches.map(({ cell }) => {\n      (satellitesByCell[cell] = satellitesByCell[cell] || []).push(index);\n      return cell;\n    });\n  });\n  return { satellitesByCell, cellsBySatellite };\n}\n\n// function computeCoverageAtDateBruteForce({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = DEFAULT_COVERAGE_ELEVATION,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   for (const [cell, cellPosition] of Object.entries(indexes.positionIndex)) {\n//     for (const position of positions) {\n//       if (arePointsNear(cellPosition, position, position.coverageRadius)) {\n//         coverage[cell]++;\n//         break;\n//       }\n//     }\n//   }\n// }\n\n// function computeCoverageAtDateH3KRing({\n//   date = new Date(),\n//   // \"positions\" or \"satellites\" and \"date\" is required\n//   satellites = null,\n//   // misc\n//   elevation = 40,\n//   // either \"resolution\" or \"cells\" is required\n//   resolution = DEFAULT_COVERAGE_RESOLUTION,\n//   cells = null,\n//   // optimizations\n//   indexes = getCellIndexes({ cells, resolution }),\n//   coverage = makeCoverage(indexes.cells),\n//   positions = getSatellitePositions(satellites, date, { elevation }),\n// }) {\n//   const covered = {};\n//   for (const position of positions) {\n//     const checked = {};\n//     const check = (cell, skipDistanceCheck = false) => {\n//       if (checked[cell]) {\n//         return;\n//       }\n//       checked[cell] = true;\n//       if (\n//         skipDistanceCheck ||\n//         arePointsNear(\n//           indexes.positionIndex[cell],\n//           position,\n//           position.coverageRadius\n//         )\n//       ) {\n//         if (!covered[cell]) {\n//           covered[cell] = true;\n//           coverage[cell]++;\n//         }\n//         for (const neighbor of h3.kRing(cell, 1)) {\n//           check(neighbor);\n//         }\n//       }\n//     };\n//     check(h3.geoToH3(position.lat, position.lng, 2), true);\n//   }\n// }\n"],"mappings":";;;;AAAA,SAASA,qBAAqB,QAAQ,cAAc;AAEpD,OAAO,KAAKC,EAAE,MAAM,OAAO;AAC3B,OAAOC,MAAM,MAAM,QAAQ;AAC3B,OAAO,KAAKC,SAAS,MAAM,WAAW;AAEtC,SACEC,2BAA2B,EAC3BC,0BAA0B,QACrB,aAAa;;AAEpB;;AAEA,OAAO,SAASC,0BAA0BA,CAAA,EAGxC;EAAA,IAFAC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,GAAG;EAAA,IACZG,SAAS,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGH,0BAA0B;EAEtC;EACA,IAAMO,GAAG,GAAG,CAAC,EAAE,GAAGD,SAAS,KAAKE,IAAI,CAACC,EAAE,GAAG,GAAG,CAAC;EAC9C,IAAMC,WAAW,GAAG,IAAI;;EAExB;EACA;EACA,IAAMC,KAAK,GAAGH,IAAI,CAACI,IAAI,CACpBJ,IAAI,CAACK,GAAG,CAACN,GAAG,CAAC,IAAIG,WAAW,GAAGR,MAAM,CAAC,GAAIQ,WAAW,CACvD;;EAED;EACA,IAAMI,KAAK,GAAGN,IAAI,CAACC,EAAE,GAAGF,GAAG,GAAGI,KAAK;;EAEnC;EACA,OAAOG,KAAK,GAAGJ,WAAW;AAC5B;;AAEA;;AAEA,OAAO,SAASK,qBAAqBA,CAAA,EAEnC;EAAA,IADAC,UAAU,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGJ,2BAA2B;EAExC,OAAOH,EAAE,CACNqB,cAAc,EAAE,CAChBC,GAAG,CAAC,UAACC,IAAI;IAAA,OAAKvB,EAAE,CAACwB,YAAY,CAACD,IAAI,EAAEH,UAAU,CAAC;EAAA,EAAC,CAChDK,IAAI,EAAE;AACX;AAEA,SAASC,cAAcA,CAAAC,IAAA,EAAsD;EAAA,IAAnDC,KAAK,GAAAD,IAAA,CAALC,KAAK;IAAAC,eAAA,GAAAF,IAAA,CAAEP,UAAU;IAAVA,UAAU,GAAAS,eAAA,cAAG1B,2BAA2B,GAAA0B,eAAA;EACvE,IAAID,KAAK,EAAE;IACT,OAAOE,sBAAsB,CAACF,KAAK,CAAC;EACtC,CAAC,MAAM;IACL,OAAOG,2BAA2B,CAACX,UAAU,CAAC;EAChD;AACF;AAEA,SAASU,sBAAsBA,CAACF,KAAK,EAAE;EACrC,IAAMI,MAAM,GAAGJ,KAAK,CAACN,GAAG,CAAC,UAACC,IAAI,EAAK;IACjC,IAAAU,WAAA,GAAmBjC,EAAE,CAACkC,OAAO,CAACX,IAAI,CAAC;MAAAY,YAAA,GAAAC,cAAA,CAAAH,WAAA;MAA5BI,GAAG,GAAAF,YAAA;MAAEG,GAAG,GAAAH,YAAA;IACf,OAAO;MAAEZ,IAAI,EAAJA,IAAI;MAAEc,GAAG,EAAHA,GAAG;MAAEC,GAAG,EAAHA;IAAI,CAAC;EAC3B,CAAC,CAAC;EACF,IAAMC,aAAa,GAAG,CAAC,CAAC;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACLT,MAAM;IAAAU,KAAA;EAAA;IAA1B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA4B;MAAA,IAAjBC,KAAK,GAAAJ,KAAA,CAAAK,KAAA;MACdR,aAAa,CAACO,KAAK,CAACvB,IAAI,CAAC,GAAGuB,KAAK;IACnC;EAAC,SAAAE,GAAA;IAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;EAAA;IAAAR,SAAA,CAAAU,CAAA;EAAA;EACD,IAAMC,aAAa,GAAG,IAAIlD,MAAM,CAC9B+B,MAAM,EACN,UAACoB,CAAC;IAAA,OAAKA,CAAC,CAACd,GAAG;EAAA,GACZ,UAACc,CAAC;IAAA,OAAKA,CAAC,CAACf,GAAG;EAAA,EACb;EACD,OAAO;IAAET,KAAK,EAALA,KAAK;IAAEW,aAAa,EAAbA,aAAa;IAAEY,aAAa,EAAbA;EAAc,CAAC;AAChD;AAEA,IAAME,mBAAmB,GAAG,CAAC,CAAC;AAC9B,SAAStB,2BAA2BA,CAAA,EAA2C;EAAA,IAA1CX,UAAU,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGJ,2BAA2B;EAC3E;EACA,IAAI,CAACkD,mBAAmB,CAACjC,UAAU,CAAC,EAAE;IACpC,IAAMQ,KAAK,GAAGT,qBAAqB,CAACC,UAAU,CAAC;IAC/CiC,mBAAmB,CAACjC,UAAU,CAAC,GAAGU,sBAAsB,CAACF,KAAK,CAAC;EACjE;EACA,OAAOyB,mBAAmB,CAACjC,UAAU,CAAC;AACxC;;AAEA;;AAEA,OAAO,SAASkC,YAAYA,CAAC1B,KAAK,EAAE;EAClC,IAAM2B,QAAQ,GAAG,CAAC,CAAC;EAAC,IAAAC,UAAA,GAAAf,0BAAA,CACDb,KAAK;IAAA6B,MAAA;EAAA;IAAxB,KAAAD,UAAA,CAAAb,CAAA,MAAAc,MAAA,GAAAD,UAAA,CAAAZ,CAAA,IAAAC,IAAA,GAA0B;MAAA,IAAftB,IAAI,GAAAkC,MAAA,CAAAV,KAAA;MACbQ,QAAQ,CAAChC,IAAI,CAAC,GAAG,CAAC;IACpB;EAAC,SAAAyB,GAAA;IAAAQ,UAAA,CAAAP,CAAA,CAAAD,GAAA;EAAA;IAAAQ,UAAA,CAAAN,CAAA;EAAA;EACD,OAAOK,QAAQ;AACjB;AAEA,OAAO,SAASG,eAAeA,CAAAC,KAAA,EAe5B;EAAA,IAbDC,UAAU,GAAAD,KAAA,CAAVC,UAAU;IAAAC,WAAA,GAAAF,KAAA,CAEVG,KAAK;IAALA,KAAK,GAAAD,WAAA,cAAGE,IAAI,CAACC,GAAG,EAAE,GAAAH,WAAA;IAAAI,YAAA,GAAAN,KAAA,CAClBO,MAAM;IAANA,MAAM,GAAAD,YAAA,cAAG,IAAI,GAAG,EAAE,GAAAA,YAAA;IAAAE,aAAA,GAAAR,KAAA,CAClBS,OAAO;IAAPA,OAAO,GAAAD,aAAA,cAAG,EAAE,GAAAA,aAAA;IAAAE,eAAA,GAAAV,KAAA,CAEZjD,SAAS;IAATA,SAAS,GAAA2D,eAAA,cAAGjE,0BAA0B,GAAAiE,eAAA;IAAAC,gBAAA,GAAAX,KAAA,CAEtCvC,UAAU;IAAVA,UAAU,GAAAkD,gBAAA,cAAGnE,2BAA2B,GAAAmE,gBAAA;IAAAC,WAAA,GAAAZ,KAAA,CACxC/B,KAAK;IAALA,KAAK,GAAA2C,WAAA,cAAG,IAAI,GAAAA,WAAA;IAAAC,aAAA,GAAAb,KAAA,CAEZc,OAAO;IAAPA,OAAO,GAAAD,aAAA,cAAG9C,cAAc,CAAC;MAAEE,KAAK,EAALA,KAAK;MAAER,UAAU,EAAVA;IAAW,CAAC,CAAC,GAAAoD,aAAA;IAAAE,cAAA,GAAAf,KAAA,CAC/CJ,QAAQ;IAARA,QAAQ,GAAAmB,cAAA,cAAGpB,YAAY,CAACmB,OAAO,CAAC7C,KAAK,CAAC,GAAA8C,cAAA;EAEtC;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,OAAO,EAAEO,CAAC,EAAE,EAAE;IAChC,IAAMC,IAAI,GAAG,IAAIb,IAAI,CAACD,KAAK,GAAGI,MAAM,GAAGS,CAAC,CAAC;IACzC,IAAAE,qBAAA,GAA6BC,uBAAuB,CAAC;QACnDF,IAAI,EAAJA,IAAI;QACJhB,UAAU,EAAVA,UAAU;QACVlD,SAAS,EAATA,SAAS;QACT+D,OAAO,EAAPA;MACF,CAAC,CAAC;MALMM,gBAAgB,GAAAF,qBAAA,CAAhBE,gBAAgB;IAMxB,SAAAC,EAAA,MAAAC,YAAA,GAAmBC,MAAM,CAACC,IAAI,CAACJ,gBAAgB,CAAC,EAAAC,EAAA,GAAAC,YAAA,CAAAzE,MAAA,EAAAwE,EAAA,IAAE;MAA7C,IAAMzD,IAAI,GAAA0D,YAAA,CAAAD,EAAA;MACbzB,QAAQ,CAAChC,IAAI,CAAC,EAAE;IAClB;EACF;EACA,SAAA6D,GAAA,MAAAC,aAAA,GAAmBH,MAAM,CAACC,IAAI,CAAC5B,QAAQ,CAAC,EAAA6B,GAAA,GAAAC,aAAA,CAAA7E,MAAA,EAAA4E,GAAA,IAAE;IAArC,IAAM7D,KAAI,GAAA8D,aAAA,CAAAD,GAAA;IACb7B,QAAQ,CAAChC,KAAI,CAAC,IAAI6C,OAAO;EAC3B;EACA;EACA,OAAOb,QAAQ;AACjB;AAEA,OAAO,IAAMuB,uBAAuB,GAAGQ,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,6BAA6BA,CAAAC,KAAA,EAYnC;EAAA,IAAAC,UAAA,GAAAD,KAAA,CAXDX,IAAI;IAAJA,IAAI,GAAAY,UAAA,cAAG,IAAIzB,IAAI,EAAE,GAAAyB,UAAA;IAAAC,gBAAA,GAAAF,KAAA,CAEjB3B,UAAU;IAAVA,UAAU,GAAA6B,gBAAA,cAAG,IAAI,GAAAA,gBAAA;IAAAC,eAAA,GAAAH,KAAA,CAEjB7E,SAAS;IAATA,SAAS,GAAAgF,eAAA,cAAGtF,0BAA0B,GAAAsF,eAAA;IAAAC,gBAAA,GAAAJ,KAAA,CAEtCnE,UAAU;IAAVA,UAAU,GAAAuE,gBAAA,cAAGxF,2BAA2B,GAAAwF,gBAAA;IAAAC,WAAA,GAAAL,KAAA,CACxC3D,KAAK;IAALA,KAAK,GAAAgE,WAAA,cAAG,IAAI,GAAAA,WAAA;IAAAC,aAAA,GAAAN,KAAA,CAEZd,OAAO;IAAPA,OAAO,GAAAoB,aAAA,cAAGnE,cAAc,CAAC;MAAEE,KAAK,EAALA,KAAK;MAAER,UAAU,EAAVA;IAAW,CAAC,CAAC,GAAAyE,aAAA;IAAAC,eAAA,GAAAP,KAAA,CAC/CQ,SAAS;IAATA,SAAS,GAAAD,eAAA,cAAG/F,qBAAqB,CAAC6D,UAAU,EAAEgB,IAAI,EAAE;MAAElE,SAAS,EAATA;IAAU,CAAC,CAAC,GAAAoF,eAAA;EAElE,IAAMf,gBAAgB,GAAG,CAAC,CAAC;EAC3B,IAAMiB,gBAAgB,GAAGD,SAAS,CAACzE,GAAG,CAAC,UAAC2E,QAAQ,EAAEC,KAAK,EAAK;IAC1D,IAAMC,OAAO,GAAGjG,SAAS,CAACkG,MAAM,CAC9B3B,OAAO,CAACtB,aAAa,EACrB8C,QAAQ,CAAC3D,GAAG,EACZ2D,QAAQ,CAAC5D,GAAG,EACZgE,QAAQ,EACRJ,QAAQ,CAACK,cAAc,CACxB;IACD,OAAOH,OAAO,CAAC7E,GAAG,CAAC,UAAAiF,KAAA,EAAc;MAAA,IAAXhF,IAAI,GAAAgF,KAAA,CAAJhF,IAAI;MACxB,CAACwD,gBAAgB,CAACxD,IAAI,CAAC,GAAGwD,gBAAgB,CAACxD,IAAI,CAAC,IAAI,EAAE,EAAEiF,IAAI,CAACN,KAAK,CAAC;MACnE,OAAO3E,IAAI;IACb,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAO;IAAEwD,gBAAgB,EAAhBA,gBAAgB;IAAEiB,gBAAgB,EAAhBA;EAAiB,CAAC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}