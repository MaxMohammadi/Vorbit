{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport axios from \"axios\";\nimport * as satellite from \"satellite.js\";\nimport * as _ from \"lodash\";\nimport { meanMotionRadPerMinute } from \"./satellites\";\nconst prototypeSatRec = satellite.twoline2satrec(`1 00001U 19029BR  20182.59692852  .00001103  00000-0  33518-4 0  9990`, `2 00001 53.00000   0.7036 0003481 299.7327   0.3331 15.05527065  1773`);\nexport function generateStarlink(shells) {\n  return shells.map((shell, index) => generateStarlinkShell(shell, index)).flat();\n}\nfunction generateStarlinkShell({\n  orbitalPlanes = 40,\n  satellitesPerOrbitalPlane = 40,\n  inclination = 53,\n  altitude = 550\n} = {}, shell) {\n  const orbitalPlanespacing = Math.PI * 2 / orbitalPlanes;\n  const satelliteSpacing = Math.PI * 2 / satellitesPerOrbitalPlane;\n  const meanMotion = meanMotionRadPerMinute(altitude);\n  const satellites = [];\n  for (let plane = 0; plane < orbitalPlanes; plane++) {\n    for (let sat = 0; sat < satellitesPerOrbitalPlane; sat++) {\n      const satnum = plane * 1000 + sat;\n      const satrec = _objectSpread(_objectSpread({}, prototypeSatRec), {}, {\n        satnum: satnum,\n        inclo: inclination * (Math.PI / 180),\n        nodeo: orbitalPlanespacing * plane,\n        ecco: 0.000542,\n        argpo: 5.156060402887908,\n        mo: satelliteSpacing * sat,\n        no: meanMotion\n      });\n      satellites.push({\n        name: \"satellite\" + satnum,\n        shell: shell,\n        plane: plane,\n        index: sat,\n        satrec: satrec\n      });\n    }\n  }\n  return satellites;\n}\nexport const loadStarlink = _.memoize(async function loadStarlink() {\n  const starlink = await axios.get(\"/api/starlink\");\n  const lines = starlink.data.split(\"\\n\");\n  const satellites = [];\n  for (let i = 0; i < lines.length; i += 3) {\n    const name = lines[i];\n    const tle = [lines[i + 1], lines[i + 2]];\n    if (name && tle[0] && tle[1]) {\n      const satrec = satellite.twoline2satrec(...tle);\n      satellites.push({\n        name,\n        tle,\n        satrec\n      });\n    }\n  }\n  return satellites;\n});","map":null,"metadata":{},"sourceType":"module"}