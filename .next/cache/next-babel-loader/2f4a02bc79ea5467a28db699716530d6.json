{"ast":null,"code":"import * as THREE from \"three\";\nimport * as _ from \"lodash\";\nimport { EARTH_RADIUS_KM } from \"../constants\";\nimport { getSatelliteCoverageRadius } from \"../coverage\";\nimport { getGatewaysAround } from \"./gateway\";\nvar objectForSatelliteIndex = _.memoize(function (index) {\n  return {\n    type: \"coverage\",\n    satelliteIndex: index\n  };\n});\nfunction computeRadius(globe, d) {\n  return getSatelliteCoverageRadius(d.position.alt, globe.config.elevation) / EARTH_RADIUS_KM * globe.radius;\n}\nfunction makeCircle(radius) {\n  var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n  var vertices = new Float32Array((segments + 1) * 3);\n  var angle = 2 * Math.PI / segments;\n  for (var i = 0; i < segments + 1; i++) {\n    vertices[i * 3] = radius * Math.sin(i * angle);\n    vertices[i * 3 + 1] = radius * Math.cos(i * angle);\n    vertices[i * 3 + 2] = 0;\n  }\n  return vertices;\n}\nfunction makeRing(globe, radius) {\n  // const mesh = new THREE.Mesh(\n  //   new THREE.RingGeometry(radius - globe.radius / 400, radius, 32),\n  //   new THREE.MeshBasicMaterial({\n  //     color: \"rgb(0,100,0)\",\n  //     side: THREE.DoubleSide,\n  //   })\n  // );\n  // mesh._radius = radius;\n  // return mesh;\n  var geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\"position\", new THREE.BufferAttribute(makeCircle(radius), 3));\n  var material = new THREE.LineBasicMaterial({\n    color: \"blue\"\n  });\n  var line = new THREE.Line(geometry, material);\n  line._radius = radius;\n  return line;\n}\nexport default {\n  name: \"Coverage (Instantaneous)\",\n  defaultConfig: {},\n  objects: function objects(_ref) {\n    var satellites = _ref.satellites;\n    return satellites.map(function (satellite, index) {\n      return objectForSatelliteIndex(index);\n    });\n  },\n  create: function create(globe, d) {\n    if (!d.position) {\n      return;\n    }\n    var radius = computeRadius(globe, d);\n    return makeRing(globe, radius);\n  },\n  update: function update(globe, d, obj) {\n    if (!d.position) {\n      return;\n    }\n    var radius = computeRadius(globe, d);\n    if (obj._radius !== radius) {\n      obj.geometry.setAttribute(\"position\", new THREE.BufferAttribute(makeCircle(radius), 3));\n      obj._radius = radius;\n    }\n    Object.assign(obj.position, globe.getCoords(d.position.lat, d.position.lng, 0));\n    var nearGateway = getGatewaysAround(globe.gatewaysIndex, d.position, d.position.coverageRadius).length > 0;\n    obj.material.color.set(nearGateway || !globe.config.layers.gateway.enabled ? \"green\" : \"rgb(100,100,0)\");\n    var globeCenter = globe.scene().localToWorld(new THREE.Vector3(0, 0, 0));\n    obj.lookAt(globeCenter);\n  },\n  renderSettings: function renderSettings() {\n    return null;\n  }\n};","map":{"version":3,"names":["THREE","_","EARTH_RADIUS_KM","getSatelliteCoverageRadius","getGatewaysAround","objectForSatelliteIndex","memoize","index","type","satelliteIndex","computeRadius","globe","d","position","alt","config","elevation","radius","makeCircle","segments","arguments","length","undefined","vertices","Float32Array","angle","Math","PI","i","sin","cos","makeRing","geometry","BufferGeometry","setAttribute","BufferAttribute","material","LineBasicMaterial","color","line","Line","_radius","name","defaultConfig","objects","_ref","satellites","map","satellite","create","update","obj","Object","assign","getCoords","lat","lng","nearGateway","gatewaysIndex","coverageRadius","set","layers","gateway","enabled","globeCenter","scene","localToWorld","Vector3","lookAt","renderSettings"],"sources":["/Users/maxmohammadi/Vorbit-Space/src/layers/coverage_instantaneous.tsx"],"sourcesContent":["import * as THREE from \"three\";\n\nimport * as _ from \"lodash\";\n\nimport { EARTH_RADIUS_KM } from \"../constants\";\nimport { getSatelliteCoverageRadius } from \"../coverage\";\nimport { getGatewaysAround } from \"./gateway\";\n\nconst objectForSatelliteIndex = _.memoize((index) => ({\n  type: \"coverage\",\n  satelliteIndex: index,\n}));\n\nfunction computeRadius(globe, d) {\n  return (\n    (getSatelliteCoverageRadius(d.position.alt, globe.config.elevation) /\n      EARTH_RADIUS_KM) *\n    globe.radius\n  );\n}\n\nfunction makeCircle(radius, segments = 32) {\n  const vertices = new Float32Array((segments + 1) * 3);\n  const angle = (2 * Math.PI) / segments;\n  for (let i = 0; i < segments + 1; i++) {\n    vertices[i * 3] = radius * Math.sin(i * angle);\n    vertices[i * 3 + 1] = radius * Math.cos(i * angle);\n    vertices[i * 3 + 2] = 0;\n  }\n  return vertices;\n}\n\nfunction makeRing(globe, radius) {\n  // const mesh = new THREE.Mesh(\n  //   new THREE.RingGeometry(radius - globe.radius / 400, radius, 32),\n  //   new THREE.MeshBasicMaterial({\n  //     color: \"rgb(0,100,0)\",\n  //     side: THREE.DoubleSide,\n  //   })\n  // );\n  // mesh._radius = radius;\n  // return mesh;\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\n    \"position\",\n    new THREE.BufferAttribute(makeCircle(radius), 3)\n  );\n  const material = new THREE.LineBasicMaterial({ color: \"blue\" });\n  const line = new THREE.Line(geometry, material);\n  line._radius = radius;\n  return line;\n}\n\nexport default {\n  name: \"Coverage (Instantaneous)\",\n  defaultConfig: {},\n  objects({ satellites }) {\n    return satellites.map((satellite, index) => objectForSatelliteIndex(index));\n  },\n  create(globe, d) {\n    if (!d.position) {\n      return;\n    }\n    const radius = computeRadius(globe, d);\n    return makeRing(globe, radius);\n  },\n  update(globe, d, obj) {\n    if (!d.position) {\n      return;\n    }\n    const radius = computeRadius(globe, d);\n    if (obj._radius !== radius) {\n      obj.geometry.setAttribute(\n        \"position\",\n        new THREE.BufferAttribute(makeCircle(radius), 3)\n      );\n      obj._radius = radius;\n    }\n    Object.assign(\n      obj.position,\n      globe.getCoords(d.position.lat, d.position.lng, 0)\n    );\n\n    const nearGateway =\n      getGatewaysAround(\n        globe.gatewaysIndex,\n        d.position,\n        d.position.coverageRadius\n      ).length > 0;\n    obj.material.color.set(\n      nearGateway || !globe.config.layers.gateway.enabled\n        ? \"green\"\n        : \"rgb(100,100,0)\"\n    );\n\n    const globeCenter = globe.scene().localToWorld(new THREE.Vector3(0, 0, 0));\n    obj.lookAt(globeCenter);\n  },\n\n  renderSettings() {\n    return null;\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}